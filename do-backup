#!/bin/sh -e

. ./libshell/shell-getopt
. ./libshell/shell-error

usage() {
  cat << EOF
Usage:  do-backup -f FILE -d DESTDIR

  Switches:
    -f, --file FILE 		Files/dirs to backup should be listed in FILE one
        per line.
        Lines starting with 'exclude:' specify locations to exclude from backup.
        Lines starting with 'pre:' and 'post:' specify shell commands to run
        before and after backup running.

        Several -f switches can be specified in which case several archives
        will be created.
    -d, --destdir DESTDIR	a target dir to put archive into
    -e, --encrypt KEY		encrypt backup with specified GPG key
    -u, --upload BUCKET		upload archive to S3 bucket
    -r, --rotate NUMBER		keep NUMBER of last archives
                                this applies both to local storage and to S3
EOF
  exit 1
}

#  rotator() - Makes actual rotation
#  Params:
#    LIST_COMMAND should produce a list of backups -- one per line
#    RM_COMMAND should remove a backup supplied as a parameter.
#    !!! NO space added after the command to let it construct paths
#        therefore you should specify 'rm -f ' instead of 'rm -f' for that
rotator() {
  [ -z "$2" ] && fatal "Usage: rotator 'LIST COMMAND' 'RM COMMAND'"

  LISTC="$1"
  RMC="$2"

  CNT=$( eval "$LISTC" | wc -l)
  if [ $CNT -gt $ROTATE ]; then
    ROT=$(($CNT - $ROTATE))
    for file in $( eval "$LISTC" | sort | head -n $ROT ); do
      eval "${RMC}${file}"
    done
  fi
}

run_hooks() {
  OLD_IFS=$IFS
  IFS="\n"
  echo "$@" | while read command; do
    eval "$command" 1>&2
  done
  IFS=$OLD_IFS
}

BACKUPLIST=""
while getoptex "d: destdir: f: file: e: encrypt: u: upload: s: secret: r: rotate:" "$@"; do
  case $OPTOPT in
    f|file)    BACKUPLIST="$BACKUPLIST $OPTARG" ;;
    d|destdir) DESTDIR="$OPTARG" ;;
    e|encrypt) ENCRYPT="$OPTARG" ;;
    u|upload)  UPLOAD="$OPTARG" ;;
    s|secret)  SECRET="--secrets-file=$OPTARG" ;;
    r|rotate)
      ROTATE="$OPTARG"
      [ "$ROTATE" -gt 0 ] || fatal "--rotate requires positive integer as a param"
      ;;
  esac
done

shift $(($OPTIND-1))
set -- $@ ${OPTUKN-}

for arg in $@; do
  fatal "Unknown option found: $arg"
done

[ -z "$BACKUPLIST" ] && usage
[ -z "$DESTDIR" ] && usage

for list in $BACKUPLIST; do
  [ -r "$list" ] || fatal "File $list is not existant or unreadable"
done

SUFFIX=$(date +%F-%T | sed 's,:,.,g')

for file in $BACKUPLIST; do
  LISTNAME=$(basename $file)
  [ -n "$ENCRYPT" ] && EXT='gpg' || EXT='tgz'
  ARCHIVE="$DESTDIR/$LISTNAME-$SUFFIX.tgz"
  MATCH="$LISTNAME-*.$EXT"
  S3MATCH="$LISTNAME-.*\.$EXT"

  BACKUP_LIST=''
  EXCLUDE_LIST=''
  while read line; do
    case "$line" in
      \#*) ;;	# a comment
      exclude:*)
         EXCLUDE_LIST="$EXCLUDE_LIST --exclude=$(echo $line | sed 's,^exclude:[[:blank:]]*,,')" ;;
      pre:*)
         PRE="$PRE\n$(echo $line | sed 's,^pre:[[:blank:]]*,,')" ;;
      post:*)
         POST="$POST\n$(echo $line | sed 's,^post:[[:blank:]]*,,')" ;;
      *) BACKUP_LIST="$BACKUP_LIST $line"
    esac
  done < "$file"

  run_hooks "$PRE"

  tar -C "$DESTDIR" -zcf "$ARCHIVE" $BACKUP_LIST $EXCLUDE_LIST
  if [ -n "$ENCRYPT" ]; then
    gpg -r "$ENCRYPT" -e "$ARCHIVE" 
    ARCHIVE="$ARCHIVE.gpg"
  fi
  [ -n "$UPLOAD" ] && aws --silent --simple "$SECRET" put "$UPLOAD/$(basename "$ARCHIVE")" "$ARCHIVE"
  echo "$ARCHIVE"

  run_hooks "$POST"

  if [ -n "$ROTATE" ]; then
    if ( echo "$file" | egrep '^(/proc|/dev)' ); then
      echo WARNING: Input file is special device or descriptor -- rotation disabled > /dev/stderr
    else
      rotator "find \"$DESTDIR\" -name \"$MATCH\"" 'rm -f '
      if [ -n "$UPLOAD" ]; then
        rotator "aws --silent --simple \"$SECRET\" ls \"$UPLOAD\" | awk '{print \$4}' | grep \"$S3MATCH\"" \
                "aws --silent --simple \"$SECRET\" rm $UPLOAD/"
      fi
    fi
  fi
done
